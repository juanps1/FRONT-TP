INSTRUCCIONES BACKEND – ALERTAS (Spring Boot)

Resumen
Diseñar e implementar un módulo de Alertas con listado filtrable/paginado, métricas, y acciones para resolver/reabrir.

1) Modelo (Entidad)
- Campos mínimos:
  - id (Long, autoincrement)
  - tipo (enum: SENSOR, CLIMATICA)
  - sensorId (String, nullable si tipo = CLIMATICA)
  - fechaHora (Instant en UTC)
  - descripcion (String, hasta ~500 chars)
  - estado (enum: ACTIVA, RESUELTA)
  - severidad (enum opcional: INFO, WARN, CRITICA)
  - origen (String opcional: "umbral", "externo", "manual")
  - resueltaEn (Instant nullable)
  - resueltaPor (Long nullable, id usuario)

Sugerencia de índices:
- (estado, fecha_hora DESC) para listar activas recientemente.
- (tipo, sensor_id) para filtros comunes.

Enums:
- public enum TipoAlerta { SENSOR, CLIMATICA }
- public enum EstadoAlerta { ACTIVA, RESUELTA }
- public enum Severidad { INFO, WARN, CRITICA }

Entidad (simplificada):
@Entity
@Table(name = "alertas",
       indexes = {
         @Index(name="idx_alerta_estado_fecha", columnList="estado, fecha_hora"),
         @Index(name="idx_alerta_tipo_sensor", columnList="tipo, sensor_id")
       })
public class Alerta {
  @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Column(nullable=false, length=15)
  private TipoAlerta tipo;

  @Column(name="sensor_id", length=100)
  private String sensorId; // null si climática

  @Column(name="fecha_hora", nullable=false)
  private Instant fechaHora;

  @Column(nullable=false, length=500)
  private String descripcion;

  @Enumerated(EnumType.STRING)
  @Column(nullable=false, length=15)
  private EstadoAlerta estado = EstadoAlerta.ACTIVA;

  @Enumerated(EnumType.STRING)
  @Column(length=15)
  private Severidad severidad;

  @Column(length=40)
  private String origen;

  private Instant resueltaEn;
  private Long resueltaPor;
  // getters/setters
}

2) DTOs
Listado:
public record AlertaListadoDto(
  Long id,
  String tipo,
  String sensorId,
  Instant fechaHora,
  String descripcion,
  String estado,
  String severidad
) {}

Detalle:
public record AlertaDetalleDto(
  Long id,
  String tipo,
  String sensorId,
  Instant fechaHora,
  String descripcion,
  String estado,
  String severidad,
  String origen,
  Instant resueltaEn,
  Long resueltaPor
) {}

Métricas:
public record AlertaMetricsDto(
  long activas,
  long nuevasHoy,
  long resueltasSemana,
  long sensorActivas,
  long climaticaActivas
) {}

3) Repositorio + Specifications
public interface AlertaRepository extends JpaRepository<Alerta, Long>, JpaSpecificationExecutor<Alerta> {
  long countByEstado(EstadoAlerta estado);
  long countByEstadoAndTipo(EstadoAlerta estado, TipoAlerta tipo);
  @Query("select count(a) from Alerta a where a.fechaHora >= :desde and a.fechaHora < :hasta")
  long countByRango(Instant desde, Instant hasta);

  @Query("select count(a) from Alerta a where a.estado = 'RESUELTA' and a.resueltaEn >= :desde")
  long countResueltasDesde(Instant desde);
}

Specifications (filtros): tipo, estado, sensorId, rango fechas, texto (like):
- Componer con Specification.where(...).and(...)

4) Servicio (lógica)
- listar: aplica specs + Pageable + sort por fechaHora DESC por defecto.
- detalle: findById → DTO.
- resolver(id, usuarioId, comentario):
  - Si ACTIVA → RESUELTA, set resueltaEn=now, resueltaPor=usuarioId (idempotente si ya RESUELTA).
- reabrir(id, usuarioId, motivo):
  - Si RESUELTA → ACTIVA, limpiar resueltaEn/resueltaPor.
- metrics(): computa KPIs (activas, nuevasHoy, resueltasSemana, por tipo activa).

5) Controlador (REST bajo /api/alertas)
GET /api/alertas
- Query: page, size, sort, tipo, estado, sensorId, desde, hasta, search
- Respuesta: Page<AlertaListadoDto>

GET /api/alertas/{id}
- Detalle.

PATCH /api/alertas/{id}/resolver
- Body: { "comentario": "..." }
- Devuelve AlertaDetalleDto

PATCH /api/alertas/{id}/reabrir
- Body: { "motivo": "..." }
- Devuelve AlertaDetalleDto

GET /api/alertas/metrics
- Resumen KPIs

DELETE /api/alertas/{id}
- Solo ADMIN

Request bodies:
public record ResolverRequest(String comentario) {}
public record ReabrirRequest(String motivo) {}

6) Generación automática de alertas
- Desde mediciones: si umbrales excedidos → alerta tipo SENSOR
  - Evitar duplicados: buscar última ACTIVA similar en <5 min.
- Desde clima externo (scheduler): tipo CLIMATICA
- Manual (opcional, solo ADMIN): POST /api/alertas

Método crear básico:
public AlertaDetalleDto crear(TipoAlerta tipo, String sensorId, String descripcion, Severidad sev, String origen) {
  Alerta a = new Alerta();
  a.setTipo(tipo);
  a.setSensorId(sensorId);
  a.setDescripcion(descripcion);
  a.setSeveridad(sev);
  a.setOrigen(origen);
  a.setFechaHora(Instant.now());
  a.setEstado(EstadoAlerta.ACTIVA);
  repo.save(a);
  return toDetalleDto(a);
}

7) Seguridad / Roles
- Resolver/Reabrir: permitido USER y ADMIN.
- Eliminar: solo ADMIN (@PreAuthorize("hasRole('ADMIN')")).
- Visibilidad opcional: si USER solo ve sus sensores → filtrar por sensorIds permitidos o (tipo=CLIMATICA).

8) Validaciones
- tipo SENSOR requiere sensorId no nulo.
- tipo CLIMATICA → sensorId null.
- descripcion obligatoria.
- Resolver ya resuelta y reabrir ya activa → idempotente (no error) o 409 según diseño.

9) Métricas y performance
- Usar índices sugeridos.
- Cache ligera (Caffeine) para metrics (TTL 30–60s) si se consulta seguido.

10) Tests
Unit:
- Crear alerta (sensor/climática).
- Resolver → cambia estado/fecha/usuario.
- Reabrir → vuelve a ACTIVA.
- Filtros combinados y búsqueda texto.

Integración (SpringBootTest):
- GET listado con paginación/orden.
- PATCH resolver/reabrir.
- DELETE con rol admin (403 para user).

11) Orden de implementación
1. Enums + Entidad + migración (Flyway/Liquibase si usan).
2. Repository + Specifications.
3. Service: listar/detalle/metrics + mappers.
4. Controller: GET /api/alertas y /metrics.
5. Resolver/Reabrir (PATCH) y DELETE (admin).
6. Integrar creación automática desde mediciones.
7. Seguridad (roles/PreAuthorize).
8. Tests unit/integración.
9. Optimización índices/cache.

12) Ejemplos JSON
Respuesta listado (item):
{
  "id": 123,
  "tipo": "SENSOR",
  "sensorId": "SEN-001",
  "fechaHora": "2025-11-10T14:23:00Z",
  "descripcion": "Temperatura fuera de rango",
  "estado": "ACTIVA",
  "severidad": "CRITICA"
}

Resolver:
PATCH /api/alertas/123/resolver
{
  "comentario": "Verificado y mitigado"
}

Reabrir:
PATCH /api/alertas/123/reabrir
{
  "motivo": "Se reprodujo el evento"
}

Notas finales
- Guardar fechas en UTC (Instant); el frontend formatea a local.
- Prefijar rutas con /api y respetar CORS ya configurado.
- Mantener operaciones idempotentes en resolver/reabrir para evitar errores de concurrencia.
